#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <err.h>
#include <string.h>
#include <sys/wait.h>

const int BUFF_SIZE = 4096;

void echo(void);
void execute(const char* command);
void validate_argument(const char* arg, const char* message);

void validate_argument(const char* arg, const char* message) {
    if (strlen(arg) > 4) {
        errx(5, "Invalid %s length. max length allowed - 4", message);
    }
}

void echo(void) {
    char c;
    int bytes_read;
    while ((bytes_read = read(0, &c, sizeof(c))) == sizeof(c)) {
        if (write(1, &c, sizeof(c)) != sizeof(c)) {
            err(3, "Could not write to stdout.");
        }
    }

    if (bytes_read == -1) {
        err(2, "Could not read from stdin");
    }
}

void execute(const char* command) {
    char buff[BUFF_SIZE], c;
    int bytes_read, index = 0;
    while ((bytes_read = read(0, &c, sizeof(c))) == sizeof(c)) {
        if (c == ' ' || c == '\n' || c == '\t') {
            buff[index] = '\0';
            index = 0;
            if (strlen(buff) > 0) {
                validate_argument(buff, "string");
                const pid_t child = fork();
                if (child == -1) {
                    err(4, "Could not fork.");
                }

                if (child == 0) {
                    if (execlp(command, buff, buff, (char *)NULL) == -1) {
                        err(5, "Could not execute command %s %s.", command, buff);
                    }
                }

                int status;
                if (wait(&status) == -1) {
                    err(6, "Could not wait for child process.");
                }

                if (!WIFEXITED(status)) {
                    errx(7, "Child process did not terminate normally");
                }

                if (WEXITSTATUS(status) != 0) {
                    errx(8, "Child process finished with exit status not 0");
                }
            }
        } else {
            buff[index] = c;
            index++;
        }
    }

    if (bytes_read == -1) {
        err(2, "Could not read from stdin.");
    }
}

int main(int argc, char** argv) {
    if (argc > 2) {
        errx(1, "Invalid arguments. Usage %s [<command>]", argv[0]);
    }

    const char* command = argv[1];
    if (argc == 2) {
        validate_argument(command, "command");
        execute(command);
    } else {
        echo();
    }
}